# 最佳实践

<cite>
**本文档中引用的文件**   
- [README.md](file://README.md)
- [src\agentscope\__init__.py](file://src\agentscope\__init__.py)
- [src\agentscope\_run_config.py](file://src\agentscope\_run_config.py)
- [src\agentscope\_logging.py](file://src\agentscope\_logging.py)
- [src\agentscope\exception\__init__.py](file://src\agentscope\exception\__init__.py)
- [src\agentscope\exception\_tool.py](file://src\agentscope\exception\_tool.py)
- [src\agentscope\tool\__init__.py](file://src\agentscope\tool\__init__.py)
- [src\agentscope\tool\_async_wrapper.py](file://src\agentscope\tool\_async_wrapper.py)
- [src\agentscope\agent\_agent_base.py](file://src\agentscope\agent\_agent_base.py)
- [src\agentscope\pipeline\_msghub.py](file://src\agentscope\pipeline\_msghub.py)
- [src\agentscope\tracing\_setup.py](file://src\agentscope\tracing\_setup.py)
- [src\agentscope\memory\_reme\_reme_long_term_memory_base.py](file://src\agentscope\memory\_reme\_reme_long_term_memory_base.py)
- [CONTRIBUTING.md](file://CONTRIBUTING.md)
</cite>

## 目录
1. [简介](#简介)
2. [性能优化](#性能优化)
3. [错误处理与异常恢复](#错误处理与异常恢复)
4. [安全考虑](#安全考虑)
5. [可维护性建议](#可维护性建议)
6. [可扩展性设计模式](#可扩展性设计模式)
7. [实际案例](#实际案例)
8. [常见陷阱](#常见陷阱)
9. [结论](#结论)

## 简介

AgentScope 是一个面向开发者的多智能体应用开发框架，旨在提供灵活且强大的工具来构建基于大语言模型（LLM）的应用程序。该框架强调透明性、实时控制和模块化设计，使开发者能够轻松地构建、调试和部署复杂的智能体系统。

AgentScope 的核心特性包括：
- **透明性**：所有操作对开发者可见，无深层封装。
- **实时控制**：支持实时中断和自定义处理。
- **模块化**：所有组件独立且可复用。
- **异步执行**：支持异步调用和流式返回。

**本节来源**
- [README.md](file://README.md#L74-L89)

## 性能优化

### 内存管理

AgentScope 提供了多种内存管理机制，以应对上下文过长导致的性能下降问题（即“上下文腐烂”）。有效的内存管理对于维持性能、支持长期任务、降低成本、保持推理质量和可扩展性至关重要。

**短时记忆管理**：
- **自动内存管理**：通过配置 `ReMeShortTermMemory` 实现自动压缩和总结。
- **阈值触发**：当总令牌数超过 `max_total_tokens` 且压缩比率超过 `compact_ratio_threshold` 时触发总结。
- **异步上下文管理器**：使用 `async with` 确保资源的正确初始化和清理。

```python
short_term_memory = ReMeShortTermMemory(
    model=llm,
    working_summary_mode="auto",
    compact_ratio_threshold=0.75,
    max_total_tokens=20000,
    max_tool_message_tokens=2000,
    keep_recent_count=1,
    store_dir="inmemory",
)
```

**长时记忆管理**：
- **ReMe 集成**：通过 `ReMeLongTermMemoryBase` 类实现持久化、可搜索的记忆。
- **异步上下文管理器**：所有内存操作必须在 `async with` 上下文中进行，以确保资源的正确管理。

```python
async with long_term_memory:
    await long_term_memory.record(msgs=[...])
    result = await long_term_memory.retrieve(msg=...)
```

**本节来源**
- [src\agentscope\memory\_reme\_reme_long_term_memory_base.py](file://src\agentscope\memory\_reme\_reme_long_term_memory_base.py#L1-L371)
- [examples\functionality\short_term_memory\reme\README.md](file://examples\functionality\short_term_memory\reme\README.md#L24-L50)

### 连接池配置

AgentScope 通过异步执行和流式返回优化了连接池的使用。异步调用允许并发处理多个请求，从而提高资源利用率和响应速度。

**异步调用**：
- **并发工具调用**：支持并行调用多个工具函数。
- **流式返回**：支持流式和非流式返回，减少延迟。

```python
async def main():
    toolkit = Toolkit()
    toolkit.register_tool_function(execute_python_code)
    toolkit.register_tool_function(execute_shell_command)

    agent = ReActAgent(
        name="Friday",
        sys_prompt="You're a helpful assistant named Friday.",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=True,
        ),
        memory=InMemoryMemory(),
        formatter=DashScopeChatFormatter(),
        toolkit=toolkit,
    )

    user = UserAgent(name="user")

    msg = None
    while True:
        msg = await agent(msg)
        msg = await user(msg)
        if msg.get_text_content() == "exit":
            break
```

**本节来源**
- [README.md](file://README.md#L206-L242)
- [src\agentscope\tool\__init__.py](file://src\agentscope\tool\__init__.py#L1-L45)

### 异步IO使用

AgentScope 全面支持异步IO，通过 `asyncio` 实现高效的并发处理。异步IO可以显著提高应用程序的响应速度和吞吐量。

**异步生成器**：
- **对象包装**：将普通对象包装成异步生成器。
- **同步生成器包装**：将同步生成器包装成异步生成器。
- **异步生成器包装**：处理异步生成器的中断和后处理。

```python
async def _object_wrapper(obj: ToolResponse, postprocess_func: Callable[[ToolResponse], ToolResponse | None] | None) -> AsyncGenerator[ToolResponse, None]:
    yield await _postprocess_tool_response(obj, postprocess_func)

async def _sync_generator_wrapper(sync_generator: Generator[ToolResponse, None, None], postprocess_func: Callable[[ToolResponse], ToolResponse | None] | Callable[[ToolResponse], Awaitable[ToolResponse | None]] | None) -> AsyncGenerator[ToolResponse, None]:
    for chunk in sync_generator:
        yield await _postprocess_tool_response(chunk, postprocess_func)

async def _async_generator_wrapper(async_func: AsyncGenerator[ToolResponse, None], postprocess_func: Callable[[ToolResponse], ToolResponse | None] | Callable[[ToolResponse], Awaitable[ToolResponse | None]] | None) -> AsyncGenerator[ToolResponse, None]:
    last_chunk = None
    try:
        async for chunk in async_func:
            processed_chunk = await _postprocess_tool_response(chunk, postprocess_func)
            yield processed_chunk
            last_chunk = processed_chunk
    except asyncio.CancelledError:
        interrupted_info = TextBlock(
            type="text",
            text="<system-info>The tool call has been interrupted by the user.</system-info>",
        )
        if last_chunk:
            last_chunk.content.append(interrupted_info)
            last_chunk.is_interrupted = True
            last_chunk.is_last = True
            yield await _postprocess_tool_response(last_chunk, postprocess_func)
        else:
            yield await _postprocess_tool_response(
                ToolResponse(
                    content=[interrupted_info],
                    is_interrupted=True,
                    is_last=True,
                ),
                postprocess_func,
            )
```

**本节来源**
- [src\agentscope\tool\_async_wrapper.py](file://src\agentscope\tool\_async_wrapper.py#L1-L110)

## 错误处理与异常恢复

### 异常类型

AgentScope 定义了多种异常类型，以帮助开发者更好地处理错误。这些异常包括工具未找到、工具调用被中断和工具参数无效等。

```python
class ToolNotFoundError(AgentOrientedExceptionBase):
    """当工具未找到时引发的异常。"""

class ToolInterruptedError(AgentOrientedExceptionBase):
    """当工具调用被用户中断时引发的异常。"""

class ToolInvalidArgumentsError(AgentOrientedExceptionBase):
    """当传递给工具的参数无效时引发的异常。"""
```

**本节来源**
- [src\agentscope\exception\_tool.py](file://src\agentscope\exception\_tool.py#L1-L16)

### 异常恢复策略

AgentScope 提供了多种异常恢复策略，以确保系统的稳定性和可靠性。

**中断处理**：
- **实时中断**：支持在 `ReActAgent` 中实时中断，并将中断转换为可观察的事件，以便智能体无缝恢复对话。
- **后处理机制**：提供全面的代理导向后处理机制，确保中断后的状态一致性。

```python
async def handle_interrupt(self, *args: Any, **kwargs: Any) -> Msg:
    """当回复被用户或其他因素中断时的后处理逻辑。"""
    raise NotImplementedError(
        f"The handle_interrupt function is not implemented in {self.__class__.__name__}",
    )
```

**本节来源**
- [src\agentscope\agent\_agent_base.py](file://src\agentscope\agent\_agent_base.py#L474-L484)
- [README.md](file://README.md#L245-L252)

## 安全考虑

### 输入验证

AgentScope 强调输入验证的重要性，以防止恶意输入导致的安全问题。开发者应确保所有输入数据都经过严格的验证和清理。

**验证示例**：
- **工具参数验证**：确保传递给工具的参数符合预期格式。
- **消息内容验证**：检查消息内容是否包含恶意代码或敏感信息。

```python
def validate_input(self, input_data: dict) -> bool:
    """验证输入数据的有效性。"""
    if not isinstance(input_data, dict):
        return False
    if "tool_name" not in input_data or "arguments" not in input_data:
        return False
    return True
```

**本节来源**
- [src\agentscope\tool\_toolkit.py](file://src\agentscope\tool\_toolkit.py#L1-L100)

### 权限控制

AgentScope 通过权限控制机制确保只有授权的用户和智能体可以访问特定资源。

**权限管理**：
- **用户身份验证**：确保用户身份的真实性。
- **资源访问控制**：限制对敏感资源的访问。

```python
class UserAgent(AgentBase):
    def __init__(self, name: str, permissions: list[str] = None):
        super().__init__()
        self.name = name
        self.permissions = permissions or []

    def has_permission(self, permission: str) -> bool:
        """检查用户是否具有指定权限。"""
        return permission in self.permissions
```

**本节来源**
- [src\agentscope\agent\_user_agent.py](file://src\agentscope\agent\_user_agent.py#L1-L100)

### 数据保护

AgentScope 通过多种机制保护数据的安全性和隐私。

**数据加密**：
- **传输加密**：使用 HTTPS 等安全协议传输数据。
- **存储加密**：对敏感数据进行加密存储。

**数据脱敏**：
- **敏感信息过滤**：在日志和输出中过滤敏感信息。
- **匿名化处理**：对用户数据进行匿名化处理。

```python
def sanitize_data(self, data: dict) -> dict:
    """对数据进行脱敏处理。"""
    sanitized_data = data.copy()
    if "password" in sanitized_data:
        sanitized_data["password"] = "*****"
    return sanitized_data
```

**本节来源**
- [src\agentscope\_logging.py](file://src\agentscope\_logging.py#L1-L48)

## 可维护性建议

### 代码组织

AgentScope 采用模块化设计，确保代码的清晰和可维护性。

**模块划分**：
- **功能模块**：每个功能模块独立，便于复用和测试。
- **依赖管理**：通过 `__init__.py` 文件管理模块依赖。

```python
from . import exception
from . import module
from . import message
from . import model
from . import tool
from . import formatter
from . import memory
from . import agent
from . import session
from . import embedding
from . import token
from . import evaluate
from . import pipeline
from . import tracing
from . import rag
from . import a2a
```

**本节来源**
- [src\agentscope\__init__.py](file://src\agentscope\__init__.py#L44-L60)

### 日志记录

AgentScope 提供了灵活的日志记录机制，帮助开发者调试和监控系统。

**日志配置**：
- **日志级别**：支持 INFO、DEBUG、WARNING、ERROR 和 CRITICAL 等日志级别。
- **日志输出**：支持控制台和文件输出。

```python
def setup_logger(level: str, filepath: str | None = None) -> None:
    """设置 agentscope 日志记录器。"""
    if level not in ["INFO", "DEBUG", "WARNING", "ERROR", "CRITICAL"]:
        raise ValueError(
            f"Invalid logging level: {level}. Must be one of 'INFO', 'DEBUG', 'WARNING', 'ERROR', 'CRITICAL'.",
        )
    logger.handlers.clear()
    logger.setLevel(level)
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter(_DEFAULT_FORMAT))
    logger.addHandler(handler)

    if filepath:
        handler = logging.FileHandler(filepath)
        handler.setFormatter(logging.Formatter(_DEFAULT_FORMAT))
        logger.addHandler(handler)

    logger.propagate = False
```

**本节来源**
- [src\agentscope\_logging.py](file://src\agentscope\_logging.py#L15-L47)

### 监控

AgentScope 支持 OpenTelemetry 基础的追踪，可以连接到第三方追踪平台（如阿里云云监控、Arize-Phoenix、Langfuse）。

**追踪配置**：
- **初始化追踪**：通过 `setup_tracing` 函数配置追踪端点。
- **注册运行**：向 AgentScope Studio 注册运行实例。

```python
def init(
    project: str | None = None,
    name: str | None = None,
    run_id: str | None = None,
    logging_path: str | None = None,
    logging_level: str = "INFO",
    studio_url: str | None = None,
    tracing_url: str | None = None,
) -> None:
    """初始化 agentscope 库。"""
    if project:
        _config.project = project

    if name:
        _config.name = name

    if run_id:
        _config.run_id = run_id

    setup_logger(logging_level, logging_path)

    if studio_url:
        # 注册运行
        data = {
            "id": _config.run_id,
            "project": _config.project,
            "name": _config.name,
            "timestamp": _config.created_at,
            "pid": os.getpid(),
            "status": "running",
            "run_dir": "",
        }
        response = requests.post(
            url=f"{studio_url}/trpc/registerRun",
            json=data,
        )
        response.raise_for_status()

        from .agent import UserAgent, StudioUserInput

        UserAgent.override_class_input_method(
            StudioUserInput(
                studio_url=studio_url,
                run_id=_config.run_id,
                max_retries=3,
            ),
        )

        _equip_as_studio_hooks(studio_url)

    if tracing_url:
        endpoint = tracing_url
    else:
        endpoint = studio_url.strip("/") + "/v1/traces" if studio_url else None

    if endpoint:
        from .tracing import setup_tracing

        setup_tracing(endpoint=endpoint)
        _config.trace_enabled = True
```

**本节来源**
- [src\agentscope\__init__.py](file://src\agentscope\__init__.py#L72-L157)
- [src\agentscope\tracing\_setup.py](file://src\agentscope\tracing\_setup.py#L1-L50)

## 可扩展性设计模式

### 微服务集成

AgentScope 支持微服务架构，通过 MCP（Microservice Communication Protocol）实现服务间的通信。

**MCP 客户端**：
- **状态化和无状态模式**：支持状态化和无状态的 MCP 客户端。
- **细粒度控制**：支持客户端和函数级别的细粒度控制。

```python
from agentscope.mcp import HttpStatelessClient
from agentscope.tool import Toolkit
import os

async def fine_grained_mcp_control():
    # 初始化 MCP 客户端
    client = HttpStatelessClient(
        name="gaode_mcp",
        transport="streamable_http",
        url=f"https://mcp.amap.com/mcp?key={os.environ['GAODE_API_KEY']}",
    )

    # 获取 MCP 工具作为本地可调用函数
    func = await client.get_callable_function(func_name="maps_geo")

    # 直接调用
    await func(address="Tiananmen Square", city="Beijing")

    # 传递给智能体作为工具
    toolkit = Toolkit()
    toolkit.register_tool_function(func)
    # ...
```

**本节来源**
- [README.md](file://README.md#L259-L284)

## 实际案例

### 多智能体对话

AgentScope 提供了 `MsgHub` 和管道来简化多智能体对话，提供高效的消息路由和无缝的信息共享。

```python
from agentscope.pipeline import MsgHub, sequential_pipeline
from agentscope.message import Msg
import asyncio

async def multi_agent_conversation():
    # 创建智能体
    agent1 = ...
    agent2 = ...
    agent3 = ...
    agent4 = ...

    # 创建消息中心管理多智能体对话
    async with MsgHub(
        participants=[agent1, agent2, agent3],
        announcement=Msg("Host", "Introduce yourselves.", "assistant")
    ) as hub:
        # 按顺序发言
        await sequential_pipeline([agent1, agent2, agent3])
        # 动态管理参与者
        hub.add(agent4)
        hub.delete(agent3)
        await hub.broadcast(Msg("Host", "Goodbye!", "assistant"))

asyncio.run(multi_agent_conversation())
```

**本节来源**
- [README.md](file://README.md#L291-L314)

## 常见陷阱

### 上下文过长

上下文过长会导致模型性能显著下降，表现为重复响应、推理速度变慢、响应质量下降和失去焦点。有效的上下文管理是解决这一问题的关键。

**解决方案**：
- **自动压缩**：定期压缩和总结长上下文。
- **分批处理**：将大任务分解为小任务，逐步处理。

**本节来源**
- [examples\functionality\short_term_memory\reme\README.md](file://examples\functionality\short_term_memory\reme\README.md#L24-L32)

### 异步调用错误

异步调用中的错误处理不当可能导致程序崩溃或数据丢失。

**解决方案**：
- **异常捕获**：使用 `try-except` 捕获异步调用中的异常。
- **重试机制**：实现重试机制，确保关键操作的可靠性。

```python
async def safe_async_call(func, *args, **kwargs):
    try:
        return await func(*args, **kwargs)
    except Exception as e:
        logger.error(f"Async call failed: {e}")
        # 重试逻辑
        return await safe_async_call(func, *args, **kwargs)
```

**本节来源**
- [src\agentscope\tool\_async_wrapper.py](file://src\agentscope\tool\_async_wrapper.py#L74-L110)

## 结论

AgentScope 是一个功能强大且灵活的多智能体应用开发框架，通过透明性、实时控制和模块化设计，为开发者提供了构建复杂智能体系统的强大工具。本文档详细介绍了性能优化、错误处理、安全考虑、可维护性建议和可扩展性设计模式的最佳实践，帮助开发者充分利用 AgentScope 的潜力，构建高效、可靠和安全的智能体应用。

**本节来源**
- [README.md](file://README.md#L74-L89)
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L1-L246)