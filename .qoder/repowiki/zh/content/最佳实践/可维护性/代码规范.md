# 代码规范

<cite>
**本文档中引用的文件**   
- [__init__.py](file://src/agentscope/__init__.py)
- [pyproject.toml](file://pyproject.toml)
- [CONTRIBUTING.md](file://CONTRIBUTING.md)
- [_common.py](file://src/agentscope/_utils/_common.py)
- [_mixin.py](file://src/agentscope/_utils/_mixin.py)
- [_agent_base.py](file://src/agentscope/agent/_agent_base.py)
- [_model_base.py](file://src/agentscope/model/_model_base.py)
- [_toolkit.py](file://src/agentscope/tool/_toolkit.py)
- [_memory_base.py](file://src/agentscope/memory/_memory_base.py)
- [_tool.py](file://src/agentscope/types/_tool.py)
- [_react_agent.py](file://src/agentscope/agent/_react_agent.py)
- [_formatter_base.py](file://src/agentscope/formatter/_formatter_base.py)
- [_message_base.py](file://src/agentscope/message/_message_base.py)
- [.pre-commit-config.yaml](file://.pre-commit-config.yaml)
</cite>

## 目录
1. [Python代码风格要求](#python代码风格要求)
2. [核心组件组织结构](#核心组件组织结构)
3. [类设计最佳实践](#类设计最佳实践)
4. [接口抽象设计方法](#接口抽象设计方法)
5. [模块化设计原则](#模块化设计原则)
6. [命名约定](#命名约定)

## Python代码风格要求

agentscope项目遵循严格的Python代码风格规范，确保代码的一致性和可读性。项目使用pre-commit钩子来强制执行代码质量检查，包括Black、flake8和pylint等工具。

根据项目中的`.pre-commit-config.yaml`配置文件，项目使用Black代码格式化工具，设置行长度为79个字符，确保代码在标准终端中具有良好的可读性。同时，项目使用flake8进行代码风格检查，并通过`--extend-ignore=E203`参数扩展忽略某些特定的风格警告。

项目还使用pylint进行更深入的代码分析，但禁用了一些可能过于严格的检查规则，如`W0511`（TODO注释）、`W0718`（过于宽泛的异常捕获）、`C0103`（命名约定）等，以平衡代码质量和开发效率。

从代码示例中可以看出，项目遵循PEP8规范，使用4个空格进行缩进，函数和类定义之间使用两个空行分隔。代码中包含详细的文档字符串，使用Google风格的文档格式，明确描述函数的参数、返回值和异常。

项目还强调类型注解的使用，所有公共API都应包含完整的类型注解。例如，在`_agent_base.py`文件中，`AgentBase`类的属性和方法都明确标注了类型：

```python
class AgentBase(StateModule, metaclass=_AgentMeta):
    """异步代理的基类。"""

    id: str
    """代理的唯一标识符，使用shortuuid生成。"""

    supported_hook_types: list[str] = [
        "pre_reply",
        "post_reply",
        "pre_print",
        "post_print",
        "pre_observe",
        "post_observe",
    ]
    """代理基类支持的钩子类型。"""
```

**Section sources**
- [src/agentscope/agent/_agent_base.py](file://src/agentscope/agent/_agent_base.py#L30-L44)
- [.pre-commit-config.yaml](file://.pre-commit-config.yaml#L51-L102)

## 核心组件组织结构

agentscope项目采用模块化设计，将核心功能划分为多个独立的模块，每个模块负责特定的功能领域。这种设计提高了代码的可维护性和可扩展性。

项目的主要模块包括：
- `agent`：代理相关功能，包含代理基类和具体代理实现
- `model`：模型相关功能，封装不同AI模型的接口
- `tool`：工具相关功能，管理工具函数和工具调用
- `memory`：记忆相关功能，实现短期和长期记忆机制
- `message`：消息相关功能，定义消息格式和处理
- `formatter`：格式化相关功能，将消息转换为不同模型所需的格式
- `embedding`：嵌入相关功能，处理文本嵌入
- `token`：令牌相关功能，计算令牌数量
- `evaluate`：评估相关功能，提供评估基准和指标
- `pipeline`：管道相关功能，实现多代理协作流程
- `plan`：规划相关功能，支持任务分解和计划管理
- `rag`：检索增强生成相关功能，实现知识检索
- `session`：会话相关功能，管理会话状态
- `tracing`：追踪相关功能，支持分布式追踪
- `tts`：文本转语音相关功能，实现语音合成
- `a2a`：代理到代理协议相关功能，支持代理间通信

每个模块都有清晰的职责划分，通过`__init__.py`文件暴露公共API。例如，在`src/agentscope/__init__.py`文件中，项目通过`__all__`变量明确声明了对外暴露的模块和函数：

```python
__all__ = [
    # modules
    "exception",
    "module",
    "message",
    "model",
    "tool",
    "formatter",
    "memory",
    "agent",
    "session",
    "logger",
    "embedding",
    "token",
    "evaluate",
    "pipeline",
    "tracing",
    "rag",
    "a2a",
    # functions
    "init",
    "setup_logger",
    "__version__",
]
```

这种设计使得用户可以清晰地了解项目的公共API，同时隐藏了内部实现细节，提高了API的稳定性。

**Section sources**
- [src/agentscope/__init__.py](file://src/agentscope/__init__.py#L159-L181)
- [pyproject.toml](file://pyproject.toml#L2-L20)

## 类设计最佳实践

agentscope项目在类设计上遵循最佳实践，强调继承与组合的合理使用，确保代码的可扩展性和可维护性。

### 继承的使用

项目中的类继承关系清晰，基类定义了通用的接口和行为，子类负责实现具体的功能。例如，`AgentBase`类作为所有代理的基类，定义了代理的基本接口：

```python
class AgentBase(StateModule, metaclass=_AgentMeta):
    """异步代理的基类。"""

    def __init__(self) -> None:
        """初始化代理。"""
        super().__init__()
        self.id = shortuuid.uuid()

    async def observe(self, msg: Msg | list[Msg] | None) -> None:
        """接收给定的消息而不生成回复。"""
        raise NotImplementedError(
            f"在{self.__class__.__name__}类中未实现observe函数。"
        )

    async def reply(self, *args: Any, **kwargs: Any) -> Msg:
        """代理的主要逻辑，根据当前状态和输入参数生成回复。"""
        raise NotImplementedError(
            f"在{self.__class__.__name__}类中未实现reply函数。"
        )
```

`ReActAgent`类继承自`ReActAgentBase`，而`ReActAgentBase`又继承自`AgentBase`，形成了清晰的继承层次。这种设计使得子类可以复用基类的通用功能，同时专注于实现特定的业务逻辑。

### 组合的使用

项目大量使用组合模式，通过组合不同的组件来构建复杂的功能。例如，`ReActAgent`类通过组合`ChatModelBase`、`FormatterBase`、`Toolkit`、`MemoryBase`等组件来实现其功能：

```python
class ReActAgent(ReActAgentBase):
    """AgentScope中的ReAct代理实现。"""

    def __init__(
        self,
        name: str,
        sys_prompt: str,
        model: ChatModelBase,
        formatter: FormatterBase,
        toolkit: Toolkit | None = None,
        memory: MemoryBase | None = None,
        long_term_memory: LongTermMemoryBase | None = None,
        # ... 其他参数
    ) -> None:
        super().__init__()

        self.name = name
        self._sys_prompt = sys_prompt
        self.max_iters = max_iters
        self.model = model
        self.formatter = formatter
        self.tts_model = tts_model

        # -------------- 记忆管理 --------------
        self.memory = memory or InMemoryMemory()
        self.long_term_memory = long_term_memory

        # -------------- 工具管理 --------------
        self.toolkit = toolkit or Toolkit()
        if self._agent_control:
            self.toolkit.register_tool_function(
                long_term_memory.record_to_memory,
            )
            self.toolkit.register_tool_function(
                long_term_memory.retrieve_from_memory,
            )
        if enable_meta_tool:
            self.toolkit.register_tool_function(
                self.toolkit.reset_equipped_tools,
            )
```

这种设计使得`ReActAgent`类可以灵活地使用不同的模型、格式化器、工具包和记忆实现，提高了代码的灵活性和可测试性。

### 抽象基类的使用

项目使用抽象基类（ABC）来定义接口规范，确保子类实现必要的方法。例如，`ChatModelBase`类定义了聊天模型的通用接口：

```python
class ChatModelBase:
    """聊天模型的基类。"""

    model_name: str
    """模型名称"""

    stream: bool
    """模型输出是否为流式"""

    def __init__(
        self,
        model_name: str,
        stream: bool,
    ) -> None:
        self.model_name = model_name
        self.stream = stream

    @abstractmethod
    async def __call__(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> ChatResponse | AsyncGenerator[ChatResponse, None]:
        pass
```

通过使用`@abstractmethod`装饰器，确保所有子类必须实现`__call__`方法，从而保证了API的一致性。

**Section sources**
- [src/agentscope/agent/_agent_base.py](file://src/agentscope/agent/_agent_base.py#L30-L204)
- [src/agentscope/agent/_react_agent.py](file://src/agentscope/agent/_react_agent.py#L40-L200)
- [src/agentscope/model/_model_base.py](file://src/agentscope/model/_model_base.py#L13-L44)

## 接口抽象设计方法

agentscope项目通过精心设计的接口抽象，实现了组件之间的低耦合和高内聚。项目使用抽象基类和协议来定义组件之间的交互接口，确保各组件可以独立开发和测试。

### 消息接口

`Msg`类是项目中的核心数据结构，用于在不同组件之间传递信息。它定义了消息的基本属性，如发送者名称、内容、角色等：

```python
class Msg:
    """AgentScope中的消息类。"""

    def __init__(
        self,
        name: str,
        content: str | Sequence[ContentBlock],
        role: Literal["user", "assistant", "system"],
        metadata: dict[str, JSONSerializableObject] | None = None,
        timestamp: str | None = None,
        invocation_id: str | None = None,
    ) -> None:
        self.name = name
        self.content = content
        self.role = role
        self.metadata = metadata
        self.id = shortuuid.uuid()
        self.timestamp = (
            timestamp
            or datetime.now().strftime(
                "%Y-%m-%d %H:%M:%S.%f",
            )[:-3]
        )
        self.invocation_id = invocation_id
```

`Msg`类支持多种内容类型，包括文本、工具调用、工具结果、图像、音频和视频，通过`ContentBlock`类型联合来实现。这种设计使得消息可以携带丰富的信息，同时保持接口的简洁性。

### 工具接口

`Toolkit`类是工具管理的核心，它定义了工具注册、调用和管理的接口。工具函数通过`register_tool_function`方法注册到工具包中，然后可以通过`call_tool_function`方法调用：

```python
class Toolkit(StateModule):
    """Toolkit是AgentScope中注册、管理和删除工具函数、MCP客户端、代理技能的核心模块。"""

    def register_tool_function(
        self,
        tool_func: ToolFunction,
        group_name: str | Literal["basic"] = "basic",
        preset_kwargs: dict[str, JSONSerializableObject] | None = None,
        func_description: str | None = None,
        json_schema: dict | None = None,
        # ... 其他参数
    ) -> None:
        """将工具函数注册到工具包中。"""

    async def call_tool_function(
        self,
        tool_call: ToolUseBlock,
    ) -> AsyncGenerator[ToolResponse, None]:
        """通过ToolUseBlock执行工具函数，并以统一的流模式返回工具响应块。"""
```

`Toolkit`类还支持工具分组管理，可以按组激活或停用工具，这为动态工具管理提供了基础。

### 记忆接口

`MemoryBase`类定义了记忆组件的通用接口，包括添加、删除、检索、清除等操作：

```python
class MemoryBase(StateModule):
    """AgentScope中记忆的基类。"""

    @abstractmethod
    async def add(self, *args: Any, **kwargs: Any) -> None:
        """向记忆中添加项目。"""

    @abstractmethod
    async def delete(self, *args: Any, **kwargs: Any) -> None:
        """从记忆中删除项目。"""

    @abstractmethod
    async def retrieve(self, *args: Any, **kwargs: Any) -> None:
        """从记忆中检索项目。"""

    @abstractmethod
    async def size(self) -> int:
        """获取记忆的大小。"""

    @abstractmethod
    async def clear(self) -> None:
        """清除记忆内容。"""

    @abstractmethod
    async def get_memory(self, *args: Any, **kwargs: Any) -> list[Msg]:
        """获取记忆内容。"""

    @abstractmethod
    def state_dict(self) -> dict:
        """获取记忆的状态字典。"""

    @abstractmethod
    def load_state_dict(self, state_dict: dict, strict: bool = True) -> None:
        """加载记忆的状态字典。"""
```

这种抽象设计使得不同的记忆实现（如内存记忆、长期记忆）可以互换使用，同时保持接口的一致性。

### 格式化接口

`FormatterBase`类定义了消息格式化的通用接口，将`Msg`对象转换为特定模型API所需的格式：

```python
class FormatterBase:
    """格式化器的基类。"""

    @abstractmethod
    async def format(self, *args: Any, **kwargs: Any) -> list[dict[str, Any]]:
        """将Msg对象格式化为满足API要求的字典列表。"""
```

这种设计使得项目可以轻松支持不同的模型提供商（如OpenAI、DashScope、Gemini等），只需实现相应的格式化器即可。

**Section sources**
- [src/agentscope/message/_message_base.py](file://src/agentscope/message/_message_base.py#L21-L74)
- [src/agentscope/tool/_toolkit.py](file://src/agentscope/tool/_toolkit.py#L55-L60)
- [src/agentscope/memory/_memory_base.py](file://src/agentscope/memory/_memory_base.py#L11-L45)
- [src/agentscope/formatter/_formatter_base.py](file://src/agentscope/formatter/_formatter_base.py#L11-L16)

## 模块化设计原则

agentscope项目遵循模块化设计原则，将系统分解为独立的、可重用的模块，每个模块都有明确的职责和接口。这种设计提高了代码的可维护性、可测试性和可扩展性。

### 懒加载原则

项目遵循懒加载原则，只在需要时才导入模块，以减少资源消耗。在`CONTRIBUTING.md`文档中明确指出：

> AgentScope遵循**懒加载原则**，以最小化资源加载：
> 
> - **DO**: 仅在实际使用时导入模块
>   ```python
>   def some_function():
>       import openai
>       # 在此处使用openai库
>   ```
> 
> 这种方法确保`import agentscope`保持轻量级，不会加载不必要的依赖。

这种设计使得项目在导入时非常快速，只有在实际调用相关功能时才会加载相应的依赖，提高了启动性能。

### 单一职责原则

每个模块和类都遵循单一职责原则，只负责一个特定的功能领域。例如：
- `agent`模块只负责代理相关功能
- `model`模块只负责模型相关功能
- `tool`模块只负责工具相关功能
- `memory`模块只负责记忆相关功能

这种设计使得每个模块可以独立开发、测试和维护，降低了系统的复杂性。

### 高内聚低耦合

项目通过清晰的接口定义和依赖管理，实现了高内聚低耦合的设计。例如，`ReActAgent`类通过构造函数参数接收其依赖的组件（如`model`、`formatter`、`toolkit`、`memory`），而不是直接创建这些组件：

```python
def __init__(
    self,
    name: str,
    sys_prompt: str,
    model: ChatModelBase,
    formatter: FormatterBase,
    toolkit: Toolkit | None = None,
    memory: MemoryBase | None = None,
    # ... 其他参数
) -> None:
    super().__init__()

    self.name = name
    self._sys_prompt = sys_prompt
    self.max_iters = max_iters
    self.model = model
    self.formatter = formatter
    self.tts_model = tts_model

    self.memory = memory or InMemoryMemory()
    self.long_term_memory = long_term_memory

    self.toolkit = toolkit or Toolkit()
```

这种依赖注入的设计使得`ReActAgent`类与其依赖组件解耦，可以轻松地替换不同的实现，提高了代码的灵活性和可测试性。

### 可扩展性设计

项目通过插件化设计支持功能扩展。例如，`Toolkit`类支持动态注册和管理工具函数，`FormatterBase`类支持为不同的模型提供商实现自定义格式化器。这种设计使得项目可以轻松地集成新的功能，而无需修改核心代码。

**Section sources**
- [CONTRIBUTING.md](file://CONTRIBUTING.md#L77-L88)
- [src/agentscope/agent/_react_agent.py](file://src/agentscope/agent/_react_agent.py#L53-L134)

## 命名约定

agentscope项目遵循一致的命名约定，确保代码的可读性和一致性。项目主要遵循PEP8命名规范，同时根据具体场景采用适当的命名策略。

### 变量和函数命名

变量和函数名称使用小写字母和下划线分隔（snake_case），以提高可读性。例如：

```python
def _generate_random_suffix(length: int) -> str:
    """生成随机后缀。"""
    return shortuuid.uuid()[:length]

def _get_timestamp(add_random_suffix: bool = False) -> str:
    """获取当前时间戳，格式为YYYY-MM-DD HH:MM:SS.sss。"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]

    if add_random_suffix:
        # 为时间戳添加随机后缀
        timestamp += f"_{os.urandom(3).hex()}"

    return timestamp
```

私有函数和变量以单个下划线开头，表示它们是内部实现细节，不应在模块外部直接访问。

### 类命名

类名称使用驼峰命名法（PascalCase），首字母大写。例如：

```python
class AgentBase(StateModule, metaclass=_AgentMeta):
    """异步代理的基类。"""

class ChatModelBase:
    """聊天模型的基类。"""

class MemoryBase(StateModule):
    """AgentScope中记忆的基类。"""
```

抽象基类通常以"Base"结尾，明确表示它们是基类，不应直接实例化。

### 常量命名

常量名称使用大写字母和下划线分隔（UPPER_CASE），以区别于普通变量。例如：

```python
_TOOL_CHOICE_MODES = ["auto", "none", "required"]
"""工具选择模式"""

supported_hook_types: list[str] = [
    "pre_reply",
    "post_reply",
    "pre_print",
    "post_print",
    "pre_observe",
    "post_observe",
]
"""代理基类支持的钩子类型。"""
```

### 类型别名

项目使用类型别名来提高代码的可读性和可维护性。例如，在`types/_tool.py`文件中定义了`ToolFunction`类型别名：

```python
ToolFunction = Callable[
    ...,
    Union[
        # 同步函数
        ToolResponse,
        # 异步函数
        Awaitable[ToolResponse],
        # 同步生成器函数
        Generator[ToolResponse, None, None],
        # 异步生成器函数
        AsyncGenerator[ToolResponse, None],
        # 返回异步生成器的异步函数
        Coroutine[Any, Any, AsyncGenerator[ToolResponse, None]],
        # 返回同步生成器的异步函数
        Coroutine[Any, Any, Generator[ToolResponse, None, None]],
    ],
]
```

这种类型别名使得函数签名更加清晰，同时也便于在多个地方重用相同的类型定义。

**Section sources**
- [src/agentscope/_utils/_common.py](file://src/agentscope/_utils/_common.py#L16-L89)
- [src/agentscope/model/_model_base.py](file://src/agentscope/model/_model_base.py#L10-L11)
- [src/agentscope/agent/_agent_base.py](file://src/agentscope/agent/_agent_base.py#L36-L43)
- [src/agentscope/types/_tool.py](file://src/agentscope/types/_tool.py#L20-L36)